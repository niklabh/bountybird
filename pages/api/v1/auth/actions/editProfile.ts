// Copyright 2019-2025 @polka-labs/townhall authors & contributors
// This software may be modified and distributed under the terms
// of the Apache-2.0 license. See the LICENSE file for details.

import withErrorHandling from '@/src/api-middlewares/withErrorHandling';
import getTokenFromReq from '@/src/api-utils/getTokenFromReq';
import Privy from '@/src/services/Privy';
import { IUser, IApiErrorResponse } from '@/src/types';
import { userDocRef, usersCollRef } from '@/src/utils/firestore_refs';
import { StatusCodes } from 'http-status-codes';
import { NextApiHandler } from 'next';

export interface IEditProfileBody {
    name?: string;
    username?: string;
    bio?: string;
    avatar?: string;
	lens_handle?: string;
}

const handler: NextApiHandler<
IUser | IApiErrorResponse
> = async (req, res) => {
	if (req.method !== 'POST') {
		return res.status(StatusCodes.METHOD_NOT_ALLOWED).json({ error: 'Only POST method allowed.' });
	}

	const { name, username, bio, avatar, lens_handle } = req.body;

	if (!bio && !name && !username && !avatar && !lens_handle) {
		return res.status(StatusCodes.BAD_REQUEST).json({ error: 'Invalid req body.' });
	}

	if (username && typeof username !== 'string') {
		return res.status(400).json({ error: 'Invalid username' });
	}

	if (name && typeof name !== 'string') {
		return res.status(400).json({ error: 'Invalid name' });
	}

	if (bio && typeof bio !== 'string') {
		return res.status(400).json({ error: 'Invalid bio' });
	}

	if (lens_handle && typeof lens_handle !== 'string') {
		return res.status(400).json({ error: 'Invalid lens_handle' });
	}

    const token = getTokenFromReq(req);
  
    if (!token) {
      return res.status(400).json({ error: "Token missing" });
    }
  
    const privy = new Privy();
    const userId = await privy.getUserId(token);
  
    if(!userId) {
      return res.status(400).json({ error: "Invalid token" });
    }

    let user_info: IUser = await privy.getTownhallUser(userId) as any;
    if (!user_info) {
        user_info = {
            bio: null,
            created_at: new Date(),
            id: userId,
            img_url: null,
            is_username_autogenerated: null,
            lens_handle: null,
            name: null,
            privy_user: null,
            updated_at: new Date(),
            username: null,
            wishlist: []
        };
    }
    const privyUser = await privy.getPrivyUser(userId);
    user_info.privy_user = JSON.parse(JSON.stringify(privyUser));

	if (username && username !== user_info?.username) {
		const query = await usersCollRef().where('username', '==', username).get();
		if (query.docs.length > 0) {
			const user = query.docs[0].data();
			if (user.id !== userId) {
				return res.status(StatusCodes.BAD_REQUEST).json({ error: 'Username already exist.' });
			}
		}
	}

	if (user_info?.username !== username) {
		user_info.is_username_autogenerated = false;
	}

	if (!user_info?.created_at) {
		user_info.created_at = new Date();
	}

	user_info.updated_at = new Date();
	user_info.name = name || user_info.name || null;
	user_info.username = username || user_info.username || null;
	user_info.bio = bio || user_info.bio || null;
	user_info.img_url = avatar || user_info.img_url || null;
	user_info.lens_handle = lens_handle || user_info.lens_handle || null;

	await userDocRef(userId).set(user_info, { merge: true });

	res.status(StatusCodes.OK).json(user_info);
};

export default withErrorHandling(handler);