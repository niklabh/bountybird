// Copyright 2019-2025 @polka-labs/townhall authors & contributors
// This software may be modified and distributed under the terms
// of the Apache-2.0 license. See the LICENSE file for details.

import { IUser } from '@/src/types';
import algoliasearch, { SearchClient, SearchIndex } from 'algoliasearch';

class Algolia {
	private app_id: string;
	private search_api_key: string;
	private client: SearchClient;
	private indexes: {
        [key: string]: SearchIndex;
    };

	constructor() {
		this.app_id = process.env.NEXT_PUBLIC_ALGOLIA_APP_ID || '';
		this.search_api_key = process.env.NEXT_PUBLIC_ALGOLIA_SEARCH_API_KEY || '';
		this.client = algoliasearch(this.app_id, this.search_api_key);

		const prefix = process.env.NEXT_PUBLIC_INDEXES_PREFIX;
		this.indexes = {
			'bounties': this.client.initIndex(`${prefix}bounties`),
			'users': this.client.initIndex(`${prefix}users`)
		};
	}

	async getUsers(limit: number, page: number, username?: string, query?: string): Promise<{
        users: IUser[];
        total: number;
    }> {
		let filters = '';
		if (username) {
			filters += `username:${username}`;
		}

		const usersRes = await this.indexes['users'].search(query || '', {
			filters,
			hitsPerPage: limit,
			page: page
		});
		const users: IUser[] = [];
		usersRes.hits.forEach((data: any) => {
			users.push({
				bio: data.bio || null,
                created_at: data.created_at || null,
				id: data.id || null,
				img_url: data.img_url || null,
				is_username_autogenerated: data?.is_username_autogenerated || null,
                lens_handle: data.lens_handle || null,
				name: data.name || null,
				privy_user: data.privy_user || null,
				username: data.username || null,
                updated_at: data.updated_at || null,
                wishlist: data.wishlist || null,
			});
		});

		return {
			total: usersRes.nbHits,
			users: users
		};
	}

	async search(indexSuffix: string, limit: number, page: number, query?: string) {
		const res = await this.indexes[indexSuffix].search(query || '', {
			hitsPerPage: limit,
			page: page
		});
		return res;
	}

	async multiSearch(limit: number, indicesPage: { [key: string]: number; }, query?: string) {
		const indicesToSearch = Object.values(this.indexes).filter((index) => !['houses'].find((n) => index.indexName?.includes(n)));

		const multipleSearchQuery = indicesToSearch.map(index => ({ hitsPerPage: limit, indexName: index.indexName, page: indicesPage[index.indexName] || 0, query: query }));
		const res = await this.client.search(multipleSearchQuery);
		return res.results;
	}
}

export default Algolia;